# SmartTavern 前端开发文档：架构与项目结构

本文件定义 SmartTavern 前端应用（Vue + Vite + TypeScript + Tailwind CSS）的目标、目录结构、解耦策略、两种聊天显示模式（楼层对话 / 0 楼层 iframe 沙盒）、统一配置面板、代码高亮与 HTML 代码块渲染、安全与美化体系，以及构建与部署规范。遵循仓库统一开发规范（见根目录 DEVELOPMENT_NOTES.md）。

提示：
- 前端只负责 UI 与 API 调用，存储和工作流由后端独立负责。
- 部署输出为纯静态资源（dist），支持在任意静态服务器上托管。
- 设计强调“逻辑与表现分离、模块解耦、可插拔美化与主题”。

---

## 1. 功能目标与使用场景

- 左侧“设置面板”（可展开/收起）：
  - 配置聊天环境（模型、温度等）、AI API Provider、API Base URL、API Key、会话参数、渲染策略（例如启用 HTML 代码块渲染）等。
  - 所有显示模式共享同一套设置（单一真源 Store）。
- 两种聊天显示模式（同路由/同数据源）：
  - 楼层对话（Threaded Chat）：常规消息列表，每条楼层支持 Markdown、代码高亮与 HTML 代码块渲染。
  - 0 楼层（Sandbox Chat）：以单个 iframe 沙盒展示完整 HTML+CSS+JS 内容（不分楼层），适合展示可交互页面/小沙盒应用。
- 富文本渲染：
  - Markdown 支持，代码高亮（倾向 shiki 或 Prism），支持 HTML 代码块渲染（可选、默认安全隔离）。
  - 允许在某些语言标记（如 ```html:render）触发安全渲染逻辑。
- 美化与主题：
  - Tailwind + CSS Variables 设计令牌（Design Tokens），语义化样式层，便于自定义主题与二次美化。
  - 外部主题 JSON 与运行时注入，提供 ThemeProvider 与 tokens.ts。

---

## 2. 技术栈与关键库

- Vue 3（SFC, Composition API）
- Vite（Dev/Build/Preview）
- TypeScript（严格模式）
- Pinia（状态管理）
- Vue Router（视图切换）
- Tailwind CSS（原子化样式 + 语义变量）
- Markdown-it（或 md-it 生态）+ Shiki/Prism（代码高亮）
- DOMPurify（XSS 防护）
- PostMessage（父页面 ↔ iframe 沙盒通信，可选）
- 选配：Monaco Editor / CodeMirror（如需编辑代码或预览调试）

---

## 3. 目录结构（建议）

说明：以下结构是单仓库子项目 frontend_projects/SmartTavern 的 src 规划，方便二次开发与模块替换。文件名仅为建议，可按团队约定微调。

```
frontend_projects/SmartTavern/
├─ docs/
│  └─ 开发文档_架构与项目结构.md        # 本文档
├─ public/
│  ├─ favicon.ico
│  ├─ config.json                     # 运行时配置（API baseUrl、主题、flag 等）
│  └─ themes/
│     └─ default.json                 # 主题令牌（可扩展多主题）
├─ src/
│  ├─ app/
│  │  ├─ App.vue
│  │  ├─ main.ts
│  │  ├─ router.ts
│  │  └─ layouts/
│  │     └─ AppShell.vue             # 顶层框架（左侧设置面板 + 主区 + 顶部工具）
│  ├─ components/
│  │  ├─ sidebar/
│  │  │  └─ SettingsPanel.vue        # 设置面板（折叠/展开）
│  │  ├─ chat/
│  │  │  ├─ ThreadedChat.vue         # 楼层对话主组件
│  │  │  ├─ SandboxChat.vue          # 0 楼层沙盒主组件（单 iframe）
│  │  │  ├─ MessageList.vue
│  │  │  ├─ MessageItem.vue
│  │  │  ├─ CodeBlockRenderer.vue    # 代码高亮 + HTML 渲染触发
│  │  │  └─ MessageToolbar.vue       # 工具栏（复制、重试、渲染切换）
│  │  └─ common/
│  │     ├─ CollapseButton.vue
│  │     ├─ ModeSwitch.vue           # Threaded ↔ Sandbox 切换
│  │     └─ ThemeSwitch.vue
│  ├─ features/
│  │  ├─ settings/
│  │  │  ├─ store.ts                 # Pinia：全局设置（单一真源）
│  │  │  ├─ schema.ts                # Zod/自定义校验 Schema
│  │  │  └─ types.ts
│  │  ├─ chat/
│  │  │  ├─ store.ts                 # Pinia：会话/消息状态
│  │  │  ├─ service.ts               # 业务服务（组装调用 + 转换）
│  │  │  ├─ normalizer.ts            # 消息/附件/富文本规范化
│  │  │  └─ types.ts
│  │  ├─ markdown/
│  │  │  ├─ renderer.ts              # markdown-it 初始化（插件/规则）
│  │  │  ├─ highlight.ts             # 高亮实现（shiki/prism）
│  │  │  └─ sanitize.ts              # DOMPurify 封装
│  │  ├─ sandbox/
│  │  │  ├─ SandboxRenderer.vue      # 渲染 iframe + postMessage 协调
│  │  │  ├─ runtime.ts               # 沙盒运行时注入（生成 Blob URL）
│  │  │  └─ protocol.ts              # postMessage 协议定义
│  │  └─ theming/
│  │     ├─ ThemeProvider.vue
│  │     ├─ tokens.ts                # 设计令牌（CSS Variables 映射）
│  │     └─ tailwind.css             # Tailwind 入口 + 自定义层
│  ├─ services/
│  │  ├─ apiClient.ts                # HTTP 调用（遵循统一 /api 前缀）
│  │  └─ websocket.ts                # 可选：WS 流式响应
│  ├─ composables/
│  │  ├─ useSidebar.ts               # 折叠状态（持久化）
│  │  ├─ useConfig.ts                # 读取 public/config.json + 覆写策略
│  │  └─ usePersistedState.ts        # 本地持久化 Hook
│  ├─ stores/
│  │  └─ index.ts                    # Pinia 安装、持久化插件等
│  ├─ types/
│  │  ├─ api.ts
│  │  ├─ chat.ts
│  │  └─ settings.ts
│  ├─ utils/
│  │  ├─ guard.ts                    # 运行时类型守卫
│  │  ├─ enum.ts
│  │  └─ misc.ts
│  └─ styles/
│     ├─ index.css
│     └─ tailwind.css
├─ index.html
├─ package.json
├─ tsconfig.json
├─ vite.config.ts
└─ modularflow_config.py              # 动态项目管理（端口与命令声明）
```

设计要点：
- app/* 与 components/* 是“表现层”（UI 组件），不直连 API。
- features/* 是“领域/业务模块”，含 Store/Service/策略/渲染器等。
- services/* 提供“基础设施层”访问（HTTP/WS），与 features 解耦。
- theming/* 提供主题令牌与 Tailwind 扩展，外部 JSON 动态注入。
- composables/* 提供跨域通用 Hook，易测试、易复用。
- 所有 API 调用通过 services/apiClient.ts 走统一前缀 /api，严格区分 modules/workflow 命名空间。

---

## 4. 解耦原则与二次开发友好性

- 表现与逻辑分离：UI 组件不直接访问 API，仅通过 Store/Service 获取数据。
- 模块内聚、模块间松耦合：features/* 内依赖向下（services/utils），跨模块只暴露最小接口。
- 可配置/可替换：
  - 渲染策略（markdown/HTML/sandbox）可通过策略对象注入与切换。
  - API Client 拦截器可注入（鉴权、日志、Mock）。
  - 主题令牌与 CSS 变量可运行时替换（public/themes/*.json）。
- 严格类型：所有对外接口提供 types 与守卫，避免隐式耦合。

---

## 5. 应用骨架与路由

- AppShell.vue：左侧 SettingsPanel + 顶部工具栏 + 主内容区（RouterView）。
- 路由建议：
  - /chat?mode=threaded
  - /chat?mode=sandbox
  - 两模式共用相同会话 Store，切换仅变换主组件。
- ModeSwitch.vue：切换模式时，仅修改查询参数并保留状态。

---

## 6. 设置面板（SettingsPanel）

用途：
- 统一管理 API Provider、API Key、Base URL、模型名、温度、system prompt、消息最大长度、是否启用 HTML 代码块渲染、沙盒 CSP 选项、主题切换等。
- 折叠/展开：useSidebar.ts + 本地持久化（localStorage）。
- 表单校验：schema.ts（Zod 或自定义）确保每项合法。
- 与显示模式无关：settings/store.ts 作为单一真源，提供只读选择器给 UI。

---

## 7. 两种聊天显示模式（共享配置）

1) 楼层对话（ThreadedChat.vue）
- 数据源：features/chat/store.ts 中的 messages。
- 每条消息支持 Markdown + 代码高亮；当检测到 ```html:render 代码块时，可切换“渲染/源码查看”。
- CodeBlockRenderer.vue：
  - 负责语言识别、复制、折叠、渲染切换、下载。
  - HTML 渲染路径：默认通过 DOMPurify 严格白名单，或选择在局部 sandbox（Shadow DOM/iframe）内渲染。

2) 0 楼层沙盒（SandboxChat.vue）
- 以“单 iframe”承载完整页面，父子通过 postMessage 协议传递内容/事件。
- features/sandbox/runtime.ts 负责将 HTML+CSS+JS 拼装为 Blob URL（设置 CSP/nonce/strict-dynamic 等），再挂载到 iframe。
- 适合展示“小应用”“交互式 Demo”“流式增量更新”（可选）。

共享点：
- 使用相同 settings/store.ts（API 参数/渲染策略/主题）。
- 使用相同 chat/store.ts（消息与结果是同一来源），区别在于 UI 呈现层。

---

## 8. Markdown 与 HTML 代码块渲染

- markdown/renderer.ts：统一初始化 markdown-it + 插件，提供：
  - GFM 支持、表格/任务列表、行号、标题锚点等。
  - 代码块处理：将 ```lang[:flags] 解析为节点属性，并交给 CodeBlockRenderer。
- highlight.ts：封装 shiki/prism，支持暗色/亮色主题切换。
- sanitize.ts：DOMPurify 封装，提供两种策略：
  - strict：删除危险标签与属性，适合直接注入 DOM。
  - sandbox：将 HTML 在 Shadow DOM 或 iframe 中渲染，并进行 CSP 限制（更安全）。
- 建议默认关闭 HTML 自动渲染，仅当用户勾选“允许渲染 HTML 代码块”时启用。

---

## 9. API 客户端（与后端协作）

- 基础 URL：
  - 默认读取 public/config.json 的 baseUrl；若无则回落到 http://localhost:8050。
  - 统一前缀 /api，命名空间遵循 modules/workflow。
- 访问约定（对应后端网关）：
  - GET /api/modules/{module}/{api}
  - POST /api/modules/{module}/{api}
  - GET /api/workflow/{flow}/{api}
  - POST /api/workflow/{flow}/{api}
- 鉴权：
  - API Key 存于 settings.store（持久化），通过拦截器加到请求头（如 Authorization: Bearer ... 或 X-API-Key）。
- 错误处理：
  - 统一错误模型：code/message/details，转换为用户友好提示。
- 示例（TypeScript 伪代码）：
```ts
// services/apiClient.ts（示例）
export interface RequestOptions {
  method?: "GET" | "POST";
  params?: Record<string, any>;
  body?: any;
  headers?: Record<string, string>;
  signal?: AbortSignal;
}

export async function apiRequest(path: string, opt: RequestOptions = {}) {
  const baseUrl = await readRuntimeBaseUrl(); // 读取 public/config.json 或默认
  const url = new URL("/api/" + path.replace(/^\/?api\//, ""), baseUrl);

  if (opt.params) {
    Object.entries(opt.params).forEach(([k, v]) => url.searchParams.set(k, String(v)));
  }

  const res = await fetch(url.toString(), {
    method: opt.method ?? "POST",
    headers: {
      "Content-Type": "application/json",
      ...opt.headers,
      ...getAuthHeadersFromSettings(), // 从 settings.store 注入
    },
    body: opt.method === "GET" ? undefined : JSON.stringify(opt.body ?? {}),
    signal: opt.signal,
  });

  if (!res.ok) {
    throw await normalizeApiError(res);
  }
  return res.json();
}
```

- 流式（可选）：websocket.ts 实现 WS 连接，遵守“斜杠路径” function_call 约束（详见开发规范）。

---

## 10. 安全与隔离

- DOMPurify：所有富文本/HTML 必须先清理。
- iframe 沙盒：
  - 推荐 sandbox 属性：allow-scripts allow-downloads (按需)；禁止同源、禁用表单提交等。
  - CSP：Content-Security-Policy 严格限制外链脚本，建议仅允许 blob: 与 data:（按需）。
  - 通过 postMessage 通信，定义明确的协议（type/payload/schema）。
- 资源限制：对用户注入 JS 的大小/执行时间设限（可通过 Worker 或超时中止）。
- 默认最小权限：所有危险能力默认关闭，需用户显式开启。

---

## 11. 主题与美化（Tailwind + Design Tokens）

目标：让任何二次开发者无需改动核心逻辑即可“换肤美化”。

- 设计令牌（Design Tokens）：
  - features/theming/tokens.ts 定义语义令牌（如 color.bg、color.text、radius.md、spacing.md 等）。
  - 令牌映射为 CSS Variables（:root --color-bg 等）。
  - Tailwind 中通过 @layer 和 theme.extend 将语义类映射到变量。
- 外部主题：
  - public/themes/default.json 定义默认令牌值。
  - ThemeProvider.vue 负责加载 JSON 并注入 CSS Variables。
- 组件层暴露：
  - 所有可定制的间距/颜色/圆角/阴影使用语义类（如 `bg-bg`、`text-weak`、`rounded-md`），不使用硬编码色值。
  - 暴露必要的插槽与 data-attributes，便于使用自定义 CSS 覆盖。
- 示例（tailwind.css）：
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --color-bg: 255 255 255;
    --color-text: 17 24 39;
    --surface: 249 250 251;
    --primary: 99 102 241;
    /* ...更多语义变量 */
  }

  [data-theme="dark"] {
    --color-bg: 17 24 39;
    --color-text: 243 244 246;
    --surface: 31 41 55;
    --primary: 129 140 248;
  }
}

@layer utilities {
  .bg-bg { background-color: rgb(var(--color-bg)); }
  .text-main { color: rgb(var(--color-text)); }
  .bg-surface { background-color: rgb(var(--surface)); }
  .text-primary { color: rgb(var(--primary)); }
}
```

---

## 12. 核心类型与 Store 约定（示例）

```ts
// types/chat.ts
export type Role = "user" | "assistant" | "system";

export interface ChatMessage {
  id: string;
  role: Role;
  content: string;        // 原始 markdown
  htmlBlocks?: Array<{
    code: string;         // HTML 代码块内容
    mode: "render" | "source";
  }>;
  createdAt: number;
  meta?: Record<string, any>;
}
```

```ts
// features/chat/store.ts
import { defineStore } from "pinia";
import type { ChatMessage } from "@/types/chat";

export const useChatStore = defineStore("chat", {
  state: () => ({
    messages: [] as ChatMessage[],
    loading: false,
    error: null as string | null,
  }),
  actions: {
    reset() { this.messages = []; },
    append(msg: ChatMessage) { this.messages.push(msg); },
    replaceLast(msg: ChatMessage) {
      if (this.messages.length) this.messages[this.messages.length - 1] = msg;
    },
  },
});
```

```ts
// features/settings/types.ts
export interface Settings {
  baseUrl: string;
  apiKey?: string;
  provider: "openai" | "azure" | "custom";
  model: string;
  temperature: number;
  allowHtmlRender: boolean;
  sandboxCspLevel: "strict" | "moderate";
  theme: "light" | "dark" | "system";
}
```

```ts
// features/settings/store.ts
import { defineStore } from "pinia";
import type { Settings } from "./types";

const DEFAULTS: Settings = {
  baseUrl: "",
  provider: "custom",
  model: "default",
  temperature: 0.7,
  allowHtmlRender: false,
  sandboxCspLevel: "strict",
  theme: "system",
};

export const useSettingsStore = defineStore("settings", {
  state: (): Settings => ({ ...DEFAULTS }),
  actions: {
    loadFromRuntime(cfg: Partial<Settings>) { Object.assign(this, cfg); },
    enableHtmlRender(v: boolean) { this.allowHtmlRender = v; },
  },
});
```

---

## 13. iframe 沙盒运行时（要点）

- runtime.ts：
  - 组合 HTML/CSS/JS（用户内容），注入最小运行时脚本（例如接收父页面消息、发送就绪/错误事件）。
  - 使用 Blob URL（URL.createObjectURL）绑定 iframe.src。
  - 注入 CSP（Content-Security-Policy）限制外链，必要时以 nonce 控制内联脚本。
- protocol.ts：
  - 规定消息格式：{ type: "init" | "update" | "event" | "error", payload: any }。
  - 父页面：发送 init/update；子页面：发送 event/error。

---

## 14. 构建与部署（静态文件）

- 开发：
  - npm run dev （Vite）——端口在 modularflow_config.py 中注入（参见下节）。
- 生产构建：
  - npm run build —— 产物 dist 可托管于任何静态服务器。
  - 基路径（vite.config.ts 的 base）视部署路径而定（如 GitHub Pages 需设置 base）。
- 运行时配置：
  - public/config.json 提供 baseUrl/主题等，不必二次打包即可调整。
- 与后端网关约定：
  - 默认 http://localhost:8050 + /api（详见仓库开发规范）。
  - 跨域时请配置 CORS 或通过同域代理。

---

## 15. modularflow_config.py（示例）

配合动态项目管理，前端声明端口与运行命令，确保与同项目后端端口策略一致。

```python
# modularflow_config.py（常量式脚本）
FRONTEND_PORT = 5176
BACKEND_PORT = 8050      # 示例：与后端网关保持一致策略
WEBSOCKET_PORT = 8051    # 如需 WS，可按策略配置

INSTALL_COMMAND = "npm ci"
# Windows（cmd）：端口注入
DEV_COMMAND = "set PORT={port} && npm run dev"
# Unix（bash/zsh）：DEV_COMMAND = "PORT={port} npm run dev"
BUILD_COMMAND = "npm run build"
```

---

## 16. 开发规范与约束（与仓库一致）

- API 优先、统一入口：
  - 所有跨模块/工作流调用统一走 /api/{namespace}/{path}，命名空间为 modules 或 workflow。
- 斜杠路径约束（WS function_call）：
  - 仅允许 "module/api" 格式，禁止点式或反斜杠。
- 端口声明在 modularflow_config.py，避免散配。
- 不直接 import 其他模块实现层（impl），仅通过“封装层”对外提供 API。
- JSON Schema 与类型严格，为自动文档与校验打基础。

---

## 17. 开发步骤建议（落地路径）

1) 初始化工程（若当前为 JS 版本，迁移到 TS）：
   - 安装 Vue + Vite + TS + Pinia + Router + Tailwind。
   - 建立 src 目录骨架与 Pinia/Router/Tailwind 基础设施。
2) 实现 SettingsPanel 与 settings/store.ts，接入 public/config.json。
3) 实现 apiClient.ts，打通 /api 测试调用（例如 modules/project_manager/get_status）。
4) 实现 ThreadedChat.vue（markdown + 高亮 + 代码块渲染开关）。
5) 实现 SandboxChat.vue（iframe + runtime + 协议 + 安全策略）。
6) 打通 ModeSwitch 与路由查询参数，统一复用 settings 与 chat store。
7) 引入主题令牌与 ThemeProvider，输出 default.json，可切换暗色。
8) 编写 e2e/单元测试（渲染器、store、服务）。
9) 完成文档与示例，构建并在本地静态服务器验证。

---

## 18. 后续扩展点

- 多会话/会话树（分支）：features/chat/ 可扩展 session 管理与分支合并。
- 富交互楼层：在 MessageItem 中增加可折叠卡片/表单/可执行片段（走 sandbox 局部）。
- 插件体系：渲染器/拦截器/消息后处理（postprocess）以注册表形式挂载。
- 国际化（i18n）：抽离文案到 messages/，根据 settings 切换语言。
- 资源管理：附件上传/预览（图片/音视频/文件），统一归一化与权限控制。

---

## 19. 附：最小 main.ts 与 AppShell 参考

```ts
// src/app/main.ts
import { createApp } from "vue";
import { createPinia } from "pinia";
import App from "./App.vue";
import router from "./router";
import "@/features/theming/tailwind.css";

const app = createApp(App);
app.use(createPinia());
app.use(router);
app.mount("#app");
```

```vue
<!-- src/app/layouts/AppShell.vue -->
<template>
  <div class="flex h-screen bg-bg text-main">
    <aside class="w-80 border-r bg-surface" v-show="sidebar.open">
      <SettingsPanel />
    </aside>

    <main class="flex-1 overflow-auto">
      <header class="sticky top-0 z-10 bg-surface/80 backdrop-blur border-b">
        <div class="flex items-center gap-2 p-2">
          <CollapseButton @click="sidebar.toggle()" />
          <ModeSwitch />
          <ThemeSwitch />
        </div>
      </header>

      <section class="p-4">
        <RouterView />
      </section>
    </main>
  </div>
</template>

<script setup lang="ts">
import SettingsPanel from "@/components/sidebar/SettingsPanel.vue";
import CollapseButton from "@/components/common/CollapseButton.vue";
import ModeSwitch from "@/components/common/ModeSwitch.vue";
import ThemeSwitch from "@/components/common/ThemeSwitch.vue";
import { useSidebar } from "@/composables/useSidebar";
const sidebar = useSidebar();
</script>
```

---

## 20. UI 美化规范说明

- 专门的“UI 美化规范”可单独文档化（建议文件：docs/ui美化规范.md），内容包括：
  - 设计令牌命名与用途、暗色/亮色策略、Spacing/Radius/Shadow 标准层级。
  - Tailwind 层扩展与语义类映射规则。
  - 组件暴露的插槽与 data-attributes。
  - 推荐的插画/图标/动画规范（Lottie/帧率/尺寸）。
- 在未找到外部“@/ui美化规范.md”的情况下，本项目已预留 theming 模块与 JSON 主题装载机制，支持后续接入。

---

本文件作为 SmartTavern 前端的落地方案与约定基线。若遇到与后端或框架规范不一致的情况，请以仓库开发规范（DEVELOPMENT_NOTES.md）为准，并在本文件中同步更新。
---

## 21) 主题 2.0 方案：单文件“主题包（Theme Pack）”导入 + 可选 JS 扩展（安全沙盒）

为满足“导入一个主题文件即可覆盖样式”的需求，同时支持更高级的“美化扩展（包括运行 JS 将纯色背景替换为图片等）”，在 Themes 页面引入“主题包（Theme Pack）”设计。该方案在保证默认纯 CSS/token 覆盖的简洁性的前提下，提供“受控脚本扩展”，并通过沙盒和白名单 API 严格约束安全边界。规范与仓库开发约束保持一致（参考：[DEVELOPMENT_NOTES.md](DEVELOPMENT_NOTES.md)）。

### 21.1 单文件导入能力（即装即用）
- 支持两种单文件输入格式：
  - JSON 单文件（推荐体积较小/无大图）：`*.sttheme.json`
  - 压缩包单文件（含静态资源/图片/字体等）：`*.sttheme`（内部为 zip，包含 manifest + 资源）
- 用户在侧边栏 Themes 页面点击“导入主题”，选择上述文件后，立即应用：
  1) 应用 tokens（CSS Variables）
  2) 注入额外 CSS（可选）
  3) 注册/加载资源（图片/字体）（可选）
  4) 若包含“主题脚本”，根据安全设置决定是否启用（默认关闭，需要用户显式开启并信任）

UI 入口：ThemesView.vue 的“导入主题”按钮、当前主题信息、信任切换、导出/重置。  
实现文件建议：
- [frontend_projects/SmartTavern/src/features/themes/manager.ts](frontend_projects/SmartTavern/src/features/themes/manager.ts)
- [frontend_projects/SmartTavern/src/features/themes/pack.ts](frontend_projects/SmartTavern/src/features/themes/pack.ts)
- [frontend_projects/SmartTavern/src/features/themes/store.ts](frontend_projects/SmartTavern/src/features/themes/store.ts)
- [frontend_projects/SmartTavern/src/views/settings/ThemesView.vue](frontend_projects/SmartTavern/src/views/settings/ThemesView.vue)

### 21.2 Manifest（主题包清单）格式（建议）
无论是 JSON 单文件还是 zip 包，主题包至少包含一个 manifest（清单）。示例（最小可用 + 可选项）：

```json
{
  "name": "Ocean Breeze",
  "version": "1.0.0",
  "author": "Theme Studio",
  "tokens": {
    "--color-bg": "17 24 39",
    "--color-text": "243 244 246",
    "--surface": "31 41 55",
    "--primary": "129 140 248"
  },
  "css": "/* 可选：附加的全局 CSS（字符串） */\n.app-shell{backdrop-filter: blur(4px)}",
  "images": {
    "app-bg": "data:image/webp;base64,AAA..." 
  },
  "fonts": {
    "body": "data:font/ttf;base64,AAA..." 
  },
  "script": {
    "enable": true,
    "sandbox": "iframe", 
    "entry": "inline",      
    "code": "function activate(api){ api.replaceBackground('body', api.images['app-bg'], {size:'cover'}); }"
  }
}
```

- tokens：语义化 CSS 变量值（与 Tailwind Utilities 绑定），导入后立即覆盖内置令牌。
- css（可选）：附加的全局 CSS 文本，将以 &lt;style&gt; 注入（只允许样式，不允许 &lt;script&gt;）。
- images/fonts（可选）：资源表；JSON 文件可用 data:URI，zip 包则为独立文件，manifest 用相对路径引用。
- script（可选）：主题脚本声明，默认 `enable=false`；如启用需经过“信任”开关且受沙盒限制。

Tokens 与 Tailwind 的映射见 11 章“主题与美化”中 tokens 说明，本节为其“可运行时覆盖”扩展。

### 21.3 主题脚本（可选，受控执行）
目标：允许主题在“有限能力”内做样式增强，如“将纯色背景替换为图片背景、动态切换光影、滚动视差”等。  
关键原则：默认禁用脚本；只有用户在 ThemesView 显式“启用并信任”后才执行。脚本执行在沙盒环境中，通过“白名单 API”与宿主交互。

执行模型（按安全级别从高到低）：
- iframe 沙盒（默认）：脚本在 sandboxed iframe 内执行，与宿主仅通过 postMessage 通信。宿主提供受控 API。
- Web Worker（可选）：仅做计算，不直接操作 DOM，返回样式建议给宿主。
- none（纯 CSS/tokens 模式）：只应用 tokens 与 CSS，不执行任何脚本。

沙盒宿主与桥接建议文件：
- [frontend_projects/SmartTavern/src/features/themes/sandbox/host.ts](frontend_projects/SmartTavern/src/features/themes/sandbox/host.ts)
- [frontend_projects/SmartTavern/src/features/themes/sandbox/client.ts](frontend_projects/SmartTavern/src/features/themes/sandbox/client.ts)
- [frontend_projects/SmartTavern/src/features/themes/sandbox/index.html](frontend_projects/SmartTavern/src/features/themes/sandbox/index.html)

白名单 API（宿主侧提供，客户端通过 postMessage 请求）：
- setCSSVar(name, value)：设置 CSS 变量（仅样式层）
- addGlobalCSS(cssText)：注入附加 CSS（只读白名单属性校验）
- replaceBackground(selector, imageUrl, options)：将选择器指向元素背景替换为图片（支持 size/repeat/position/opacity）
- addClass(selector, className)/removeClass(selector, className)：增删样式类（仅允许白名单选择器集合，如 body、.app-shell 等）
- onRouteChange(handler)：订阅路由变化事件（回调在沙盒内触发）
- getThemeAssets()：读取主题资源映射（images/fonts）

限制：
- 禁止直接 DOM 读写；所有 DOM 操作须由宿主代理，且仅限样式属性与白名单选择器。
- 禁止跨域网络请求（或需额外“联网”权限开关）。
- CSP 强制：`script-src 'self' blob:`（生产可更严），iframe 设定 `sandbox="allow-scripts"`，禁止同源/表单/弹窗。
- 关闭时彻底清理：移除由主题脚本注入的样式与类、撤销事件订阅。

安全与合规须知：参照统一规范（API 前缀、端口一致等）与 CSP/WS 约束（参考：[python.get_api_config()](core/config/api_config.py:29)、[python.call_api()](core/api_client.py:234)）。

### 21.4 JS 扩展示例：将纯色背景改为图片背景
主题脚本（iframe 沙盒内）：
```js
function activate(api) {
  // 将 body 背景替换为主题内置图像
  api.replaceBackground("body", api.images["app-bg"], {
    size: "cover",
    position: "center center",
    repeat: "no-repeat",
    opacity: 1
  });

  // 细化：为主容器添加半透明蒙层，避免文字对比度降低
  api.addGlobalCSS(`
    .app-shell::before {
      content: "";
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.25);
      pointer-events: none;
      z-index: -1;
    }
  `);
}

function deactivate(api) {
  // 宿主将根据注入记录自动清理，这里可显式做补充清理
}
```

宿主侧会在主题启用时调用 `activate()`，停用/切换主题时调用 `deactivate()` 并清理注入。

### 21.5 持久化与导出
- 持久化：小主题（JSON/dataURI）可存 localStorage；大主题（含多图/字体）建议存 IndexedDB。
- 导出：将当前生效主题再次打包为 `*.sttheme.json` 或 `*.sttheme`，便于分享复用。
- 回退：提供“一键重置默认主题”与“临时禁用脚本仅保留样式”的快速切换。

### 21.6 UI 与用户信任流程（ThemesView）
- 导入主题：选择文件 → 解析校验 → 显示“主题信息/覆盖范围/潜在风险”
- 应用范围：
  - 覆盖 tokens（立即生效）
  - 注入 CSS（立即生效）
  - 注册资源（可用于 CSS var 或 API）
  - [可选] 启用脚本（需勾选“我信任该主题的脚本”）
- 权限设置：
  - 全局“允许主题脚本”（AppSettingsView 全局开关，默认关闭）
  - 主题“信任该脚本”（主题级开关，默认关闭）
- 可视化审计（建议）：列出主题所做改动（变量/类/CSS 注入摘要），便于快速确认。

### 21.7 与 7 个侧边栏页面的关系
- Themes 页面负责导入/启用/停用主题包，影响全局外观。
- 其他页面（Presets/Worldbook/Characters/Persona/Regex/App Settings）不受主题脚本直接影响，仅受样式层影响。
- App Settings 提供全局“允许主题脚本”开关与 CSP 强度选项（strict/moderate），默认 strict。

### 21.8 性能与回退策略
- 优先使用 tokens 与 CSS（0 JS 开销）。
- 脚本只在用户明确启用后加载；执行超时/错误自动回退到“仅样式”模式。
- 大图懒加载：主题资源可按需加载（首屏仅 tokens+CSS）；
- 监控：统计主题脚本执行时间、注入数量，用于提示性能风险。

---

结论：
- “只导入一个主题文件即可覆盖”的目标通过 Theme Pack 实现：tokens 覆盖 + 附加 CSS + 资源映射（默认不含 JS）。
- 支持“可选 JS 美化扩展”，通过 iframe 沙盒 + 白名单 API 的方式将 JS 能力限制在“样式增强”范围，满足如“将纯色背景替换为图片背景”的诉求，同时确保默认安全与可回退。
- UI 侧提供清晰的启用/信任开关与一键回退，兼顾可玩性与工程安全性。
---

## 21.9 权限级别矩阵与“任意美化”可行性说明

问题：允许用户执行 JS，是否可以实现“任意功能的美化”？  
回答：可以实现“几乎任意的 UI 美化”，但需分级授权与安全隔离。默认安全模式下不提供“任意”能力；开启“受信主题脚本（Trusted Theme）”后，可获得接近任意的样式/布局层改造能力。为防止泄露与破坏，仍建议保留 CSP、权限白名单与作用域限制。

为平衡能力与安全，引入 5 个权限等级（从安全到高风险）：

- Level 0: No-JS（默认）
  - 能力：仅 tokens（CSS Variables）+ 附加 CSS。
  - 可实现：主题换肤、颜色/圆角/阴影/字体/密度等。
  - 风险：极低，100% 可回退。

- Level 1: Sandbox-Style（默认可开启）
  - 运行环境：iframe sandbox（无同源，无网络）。
  - 能力：通过受控 API 执行样式增强（如 setCSSVar、addGlobalCSS、replaceBackground、addClass 等，详见 21.3）。
  - 可实现：将纯色背景替换为图片背景、光影/毛玻璃、局部动效（依赖宿主注入的安全 CSS Keyframes）。
  - 风险：低；无法直接访问 DOM 内容或发起网络请求。

- Level 2: Sandbox-Extended（可选）
  - 运行环境：iframe sandbox + 扩展白名单 API（读取 computedStyle、测量元素 rect、订阅滚动事件等）。
  - 能力：更强的视觉增强（视差、渐进展示、响应式变体）。
  - 风险：中；仍不可读写敏感数据、不可任意 DOM 访问。

- Level 3: Trusted Theme Script（“受信主题脚本”，需显式信任）
  - 运行环境：宿主上下文或 iframe sandbox + allow-same-origin（视实现），开启更宽 API。
  - 能力：可对“白名单作用域”内的 DOM 进行样式与布局层修改，允许声明式加载外部资源（需在 manifest.permissions 声明），可读 computedStyle、插入自定义容器、动态布局编排。
  - 可实现：“接近任意的 UI 美化”，例如：
    - 重构消息楼层的气泡形态与分栏布局（仅限样式与无业务逻辑的容器层改造）
    - 动态背景、动态主题过渡、复杂动效、皮肤级组件装饰
  - 风险：高；需严格限制“可操作选择器集合”和“可用资源域名”，并提供一键回退。

- Level 4: Dev-Full（仅开发/离线演示用，不建议对终端用户开放）
  - 能力：几乎无约束，等价于用户脚本。
  - 风险：极高；仅用于研发调试，不对外发布。

结论：
- 安全默认（Level 0/1/2）：不能达到“任意”，但覆盖绝大多数美化诉求（含“纯色→图片背景”）。  
- 若启用“受信主题脚本”（Level 3）且用户明确同意，则可实现“接近任意的 UI 美化”。仍建议保留作用域限制与资源白名单，避免读取业务数据或破坏交互。

提示：API 网关与端口规范依旧保持一致，前端侧仅在 UI 层处理美化；公共 API 参考 [python.get_api_config()](core/config/api_config.py:29) 与 [python.call_api()](core/api_client.py:234)。

### 21.10 主题包 Manifest 扩展：权限与作用域

为支撑上面的分级能力，在主题包清单（manifest）中新增字段：

```json
{
  "name": "Ocean Breeze+",
  "version": "1.1.0",
  "author": "Theme Studio",
  "tokens": { "--color-bg": "17 24 39", "...": "..." },
  "css": "/* 附加全局 CSS，可选 */",
  "images": { "app-bg": "data:image/webp;base64,AAA..." },
  "fonts": { "body": "data:font/ttf;base64,AAA..." },
  "permissions": [
    "style.vars",          // 允许设置 CSS Variables
    "style.css",           // 允许注入附加 CSS（受校验）
    "style.class",         // 允许对白名单选择器增删类名
    "dom.query.read",      // 允许宿主代为查询只读属性（如 computedStyle）
    "dom.mutate.style",    // 允许宿主代为设置 style（仅样式属性）
    "assets.external:https://cdn.example.com", // 允许从指定位点加载资源
    "events.route"         // 允许订阅路由变化
    /* 如需接近任意美化，添加 "trusted.full"（需用户显式信任） */
  ],
  "scopes": [
    "body",
    ".app-shell",
    ".message-item",
    ".message-list",
    ".chat-input"
  ],
  "script": {
    "enable": true,
    "sandbox": "iframe",
    "entry": "inline",
    "code": "function activate(api){ api.replaceBackground('body', api.images['app-bg'], { size:'cover', position:'center' }); }"
  }
}
```

- permissions：
  - 基础：style.vars/style.css/style.class（安全）
  - 扩展：dom.query.read/dom.mutate.style（需校验属性白名单）
  - 资源：assets.external:&lt;origin&gt;（必须逐域声明）
  - 事件：events.route（仅路由事件）
  - 危险：trusted.full（受信主题脚本，Level 3）
- scopes：限制可操作的选择器集合，防止越界（例如禁止直接操作 #app 外的元素）。
- script：与 21.3 一致；当 manifest 含 trusted.full 时，UI 需显示高风险提示并二次确认。

注意：JSON 单文件（.sttheme.json）可用 data:URI 内联资源；大主题建议使用 .sttheme（zip）并在内部以相对路径引用。

### 21.11 运行时开关与信任流程

- App 全局（AppSettingsView.vue）：
  - “允许主题脚本（Allow Theme Scripts）”：默认关闭。
  - “允许受信主题脚本（Allow Trusted Themes）”：默认关闭。
  - “主题脚本权限级别”：No-JS / Sandbox-Style / Sandbox-Extended / Trusted。
- 主题侧（ThemesView.vue）：
  - 显示主题声明的 permissions 与 scopes。
  - 若包含 trusted.full，需二次确认，勾选“我已知风险，信任该主题”。
  - 审计页签：展示本主题的变更摘要（变量/类/样式注入），支持一键回退。
- 开发者模式（仅 dev）：
  - 可临时启用 Dev-Full（Level 4），切换路由或刷新后自动还原。
- 状态持久化：
  - JSON 主题可持久化于 localStorage；
  - 大主题（zip）建议持久化于 IndexedDB；
  - 信任标记与权限级别独立存储，切换主题后沿用默认安全策略。

### 21.12 “任意美化”边界与安全建议

- 不建议：访问用户数据、读取消息内容、拦截输入、向外域发送敏感信息。
- 保留底线：
  - 永不将 API Key 暴露给主题脚本；鉴权仅存在于宿主的请求头拦截器层。
  - 资源请求仅限白名单域；CSP 限制 script/img/font/src。
  - 仅允许“样式层/容器层”的 DOM 变更；业务逻辑、数据流由前端自身控制。
- 性能：
  - 优先使用 tokens 与 CSS；JS 脚本懒加载、超时回退。
  - 监控注入数量与执行时长，并在启用时给予提示。
- 回退：
  - 一键禁用脚本、保留样式；或重置为默认主题。
  - 切换主题时调用 deactivate 并清理注入。

---

要点复述：
- 默认（Level 0/1/2）满足绝大多数美化；启用 Level 3 的“受信主题脚本”后，可实现“接近任意”的 UI 美化（含布局级装饰与复杂动效），但需严格权限与作用域控制。
- 强烈建议面向普通用户只提供 Level 0/1 的主题导入；Level 3 作为高级选项，在 UI 中明确风险与回退路径。
---

## 22) 编译产物（静态发布）下的美化执行与“稳定选择器契约”

问题复述：开发使用 TS，发布为静态 HTML + CSS + JS（经打包/压缩）。主题与美化如何在“编译产物”上可靠生效？编译后 DOM 结构/类名可能混乱或变化，是否需要额外文档？

答案与方案：引入“运行时主题加载器 + 稳定选择器契约 + 令牌 Hooks”，确保主题在 dist 上可重复应用，且不依赖易变的编译细节。主题创作者仅需遵循我们提供的“稳定选择器与令牌规范”，无需理解编译后的内部结构。

### 22.1 运行时主题加载器（静态产物生效机制）

- 应用启动顺序：
  1) 浏览器加载编译后的入口 [frontend_projects/SmartTavern/index.html](frontend_projects/SmartTavern/index.html)
  2) 前端入口 [frontend_projects/SmartTavern/src/app/main.ts](frontend_projects/SmartTavern/src/app/main.ts) 初始化 Pinia/Router
  3) 主题宿主 ThemeHost 在应用挂载前后读取已保存的 Theme Pack（localStorage/IndexedDB/URL 参数等），立即应用 tokens + CSS；若允许脚本，则初始化沙盒并执行主题脚本
- 主题宿主（文档与实现落点）：
  - [frontend_projects/SmartTavern/src/features/themes/manager.ts](frontend_projects/SmartTavern/src/features/themes/manager.ts)
  - [frontend_projects/SmartTavern/src/features/themes/pack.ts](frontend_projects/SmartTavern/src/features/themes/pack.ts)
  - [frontend_projects/SmartTavern/src/features/themes/store.ts](frontend_projects/SmartTavern/src/features/themes/store.ts)
  - 沙盒桥接：
    - [frontend_projects/SmartTavern/src/features/themes/sandbox/host.ts](frontend_projects/SmartTavern/src/features/themes/sandbox/host.ts)
    - [frontend_projects/SmartTavern/src/features/themes/sandbox/client.ts](frontend_projects/SmartTavern/src/features/themes/sandbox/client.ts)

补充：支持通过 URL 参数快速加载主题（无需进入 UI 导入）
- ?theme=/themes/ocean.sttheme.json 或 ?theme=/themes/ocean.sttheme
- 主题宿主在首屏解析并应用；若含脚本则仍遵循“信任开关”

### 22.2 稳定选择器契约（Stable Selectors Contract）

为避免依赖“编译后 DOM 细节（类名/结构）”，我们在源码层约定一组“稳定数据标记”，这些标记在编译后仍会原样保留，作为主题/美化的唯一挂载点。该契约会随发布版本一并出现在 dist，并保持兼容策略。

- 顶层标记（只读稳定）：
  - body[data-app="smarttavern"]
  - #app
- 语义作用域（scope）标记（组件根节点）：
  - [data-scope="app-shell"]（AppShell 主布局，参考 [frontend_projects/SmartTavern/src/app/layouts/AppShell.vue](frontend_projects/SmartTavern/src/app/layouts/AppShell.vue)）
  - [data-scope="sidebar"]、[data-scope="sidebar-nav"]
  - [data-scope="settings-view"]（设置页通用容器）
  - [data-scope="chat-threaded"]、[data-scope="message-list"]、[data-scope="message-item"]
  - [data-scope="chat-sandbox"]
  - [data-scope="themes-view"]、[data-scope="presets-view"]、[data-scope="worldbook-view"]、[data-scope="characters-view"]、[data-scope="persona-view"]、[data-scope="regex-view"]、[data-scope="appsettings-view"]
- 部件（part）标记（组件内部可定制部位）：
  - [data-part="avatar"]、[data-part="bubble"]、[data-part="toolbar"]、[data-part="content"]、[data-part="input"] 等

原则：
- 主题 CSS/脚本仅允许操作上述“稳定选择器集合”，禁止依赖内部实现类名或临时结构
- 这些标记属于“对外契约”，尽量保持跨版本兼容；如需变更，将在契约 JSON 中声明变更与替代

契约文档（随应用发布，便于主题作者查阅）：
- [frontend_projects/SmartTavern/public/themes/contract.json](frontend_projects/SmartTavern/public/themes/contract.json)
  - contractVersion：版本号
  - stableScopes：可用 scope 列表
  - stableParts：可用 part 列表
  - cssTokens：令牌清单及类型说明

### 22.3 逻辑选择器映射（可选，提升兼容性）

为进一步屏蔽选择器变更，Theme Pack 的 manifest 可使用“逻辑选择器”，由宿主在运行时映射到真实稳定选择器。

- Manifest 支持两种写法（向后兼容）：
  - 数组（之前定义）：["body", ".app-shell", ".message-item", ...]
  - 对象映射（推荐）：{"$app":"body[data-app='smarttavern']", "$appShell":"[data-scope='app-shell']", "$messageItem":"[data-scope='message-item']"}
- 主题脚本可使用逻辑名：api.replaceBackground("$app", url, opt)
- 宿主基于 contract.json 映射；当将来升级选择器时，只需更新映射即可保持主题可用

### 22.4 令牌（CSS Variables）Hooks：编译后无痛覆盖

- 语义令牌（示意）：
  - 颜色：--st-color-bg、--st-color-text、--st-surface、--st-primary、--st-border
  - 圆角：--st-radius-sm/md/lg
  - 阴影：--st-shadow-sm/md/lg
  - 密度：--st-spacing-xs/sm/md/lg
  - 背景图：--st-surface-bg-image（允许使用 url("...") 或 none）
- 应用层 CSS 在关键节点使用这些变量（Tailwind 通过 @layer utilities 映射语义类到变量）：
```css
/* 示例：背景图 Hook（主题覆盖变量即可生效） */
[data-scope="app-shell"] {
  background-color: rgb(var(--st-color-bg));
  background-image: var(--st-surface-bg-image, none);
  background-size: var(--st-surface-bg-size, cover);
  background-position: var(--st-surface-bg-position, center center);
  background-repeat: var(--st-surface-bg-repeat, no-repeat);
}
```
- 编译后，这些自定义属性仍然保留，主题仅需设置变量值即可“无 JS”生效（Level 0）

### 22.5 静态发布的主题加载路径（无需源码参与）

- UI 导入：在“主题/主体（Themes）”页面直接导入 `.sttheme.json` 或 `.sttheme`，立即应用
  - 参考： [frontend_projects/SmartTavern/src/features/themes/manager.ts](frontend_projects/SmartTavern/src/features/themes/manager.ts)、[frontend_projects/SmartTavern/src/features/themes/pack.ts](frontend_projects/SmartTavern/src/features/themes/pack.ts)
- URL 参数：`?theme=/themes/ocean.sttheme.json`
  - 适合分享链接/预置主题
- 运行时资源：主题包中的图片/字体可为 data:URI 或 zip 内部相对路径（静态托管时一并发布）
- 不需要源码：主题作者不必修改/阅读编译后的 app 代码，只需要契约与令牌清单

### 22.6 文档与发布物（给主题作者看的）

- 主题作者文档（建议新增）：[frontend_projects/SmartTavern/docs/主题创作指南.md](frontend_projects/SmartTavern/docs/主题创作指南.md)
  - 如何编写 Theme Pack（manifest 字段、tokens、css、images/fonts、permissions/scopes）
  - 稳定选择器与逻辑选择器示例
  - 令牌清单（颜色/圆角/阴影/密度/背景图等）
  - 安全与权限等级说明（参考 21.9～21.12）
  - 常见问题：编译后类名不对齐怎么办？答：仅使用数据标记与逻辑选择器
- 契约 JSON（随 dist 部署）：[frontend_projects/SmartTavern/public/themes/contract.json](frontend_projects/SmartTavern/public/themes/contract.json)
  - 为主题作者提供“机器可读”的锚点/令牌清单，避免口口相传与误差

### 22.7 示例：不改源码，仅用 Theme Pack 改纯色为图片背景

- Theme Pack（JSON）设置：
  - tokens：
    - "--st-surface-bg-image": "url('data:image/webp;base64,AAA...')"
    - "--st-surface-bg-size": "cover"
    - "--st-surface-bg-position": "center center"
    - "--st-surface-bg-repeat": "no-repeat"
  - css（可选）：增加暗角/蒙层
- 若需“动态渐变/视差”等，则在“受控脚本（Level 1/2）”下调用：
  - api.replaceBackground("$appShell", api.images["app-bg"], { size:"cover", position:"center" })
  - 仍不需要理解编译后 DOM，只使用 $appShell 逻辑选择器

### 22.8 版本兼容与升级策略

- contractVersion：当升级导致标记变化时，提升版本号，并在 ThemesView 中提示“该主题与当前版本契约不一致，可自动映射或回退”
- 选择器映射：宿主保留多版本映射表；旧主题仍可用（最佳努力）
- 回退策略：主题脚本异常或映射缺失时，自动降级到“仅 tokens + CSS”模式

---

落地摘要：
- 主题/美化在编译产物中通过“运行时加载器 + 稳定选择器契约 + CSS 令牌 Hooks”可靠生效
- 主题作者不需要阅读编译后的混淆代码，只需依据契约与令牌清单开发
- 复杂美化可启用受控脚本，并通过“逻辑选择器 + 白名单 API + 沙盒”实现，对编译产物保持稳健兼容

参考统一规范与 API 网关说明：
- [DEVELOPMENT_NOTES.md](DEVELOPMENT_NOTES.md)
- [python.get_api_config()](core/config/api_config.py:29)、[python.call_api()](core/api_client.py:234)
---

## 23) 实施答复：是否需要预埋“主题/美化 API”？

简答：
- 是。为保证静态编译产物（dist）也能稳定美化，开发阶段需要预埋两个层次的“可定制点”：
  1) 无 JS 层（默认即用，覆盖率高）：“设计令牌（CSS Variables）+ 稳定选择器契约 + contract.json”。这层无需额外 JS API，也能完成绝大多数换肤（包括把纯色背景改为图片背景）。
  2) 可选 JS 层（用户显式信任后启用）：“ThemeHost 受控 API + 沙盒桥接”。这层用于更复杂的动态美化（视差、动态过渡、布局装饰），需要在代码里暴露一组“白名单样式增强 API”。

参考文档：
- 主题作者指南：[frontend_projects/SmartTavern/docs/主题创作指南.md](frontend_projects/SmartTavern/docs/主题创作指南.md)
- 统一规范示例： [python.get_api_config()](core/config/api_config.py:29)、[python.call_api()](core/api_client.py:234)

---

### 23.1 无 JS 即可达成的美化（推荐优先支持）

只要在源码阶段做好“令牌 Hooks + 稳定选择器”，主题在运行时导入后即可生效，无需 JS API：
- 令牌（CSS Variables）示例（非代码，仅说明）：
  - --st-color-bg、--st-color-text、--st-surface、--st-primary...
  - 背景图相关：--st-surface-bg-image、--st-surface-bg-size、--st-surface-bg-position、--st-surface-bg-repeat
- 稳定选择器（data- 标记）示例（仅说明）：
  - body[data-app="smarttavern"]、[data-scope="app-shell"]、[data-scope="message-item"]...
- 做法：
  - 在布局/组件根节点使用 data-scope、data-part 标记
  - 在样式中用 CSS Variables 驱动关键视觉位（颜色、圆角、阴影、密度、背景图）
  - 发布时附带 contract.json，列出“可用的稳定选择器与令牌清单”
- 结果：主题作者只需在主题包（.sttheme.json/.sttheme）里覆盖 tokens，即可把纯色背景替换为图片背景，无需任何 JS。

---

### 23.2 何时需要“暴露 JS API”？（ThemeHost 受控 API）

当你希望开放“动态/交互式”的美化增强（例如：滚动视差、时段切换背景、复杂动效编排），这超出纯 CSS 的覆盖能力，就需要在开发阶段提供以下“受控 API”（通过沙盒桥接给主题脚本使用，默认关闭，启用需用户显式信任）：
- setCSSVar(name, value)：设置单个 CSS 变量
- addGlobalCSS(cssText)：注入附加 CSS（经过校验）
- replaceBackground(selector, imageUrl, options)：将指定作用域的背景替换为图片或渐变（支持 size/position/repeat/opacity）
- addClass(selector, className) / removeClass(selector, className)：对白名单作用域增删类
- onRouteChange(handler)：订阅路由切换事件（仅用于样式联动，不暴露业务数据）
- getThemeAssets()：读取主题包内资源映射（不经网络）
说明：
- 这些 API 均由宿主代理，脚本不能直接操作 DOM 或网络；默认 iframe sandbox 执行。
- 启用条件：App 设置开启“允许主题脚本”，且该主题被标记为“已信任”。
- 安全回退：脚本异常或超时自动降级到“仅样式模式”。

---

### 23.3 最小实施清单（面向开发者）

为落地“无 JS + 可选 JS”的双层方案，源码阶段建议完成以下内容：
- 结构与标记
  - 在关键容器/组件根增加稳定标记：data-app、data-scope、data-part
  - 输出契约文件 contract.json（随 dist 部署），列出稳定选择器与令牌清单
- 令牌与样式
  - 在全局样式（Tailwind 自定义层）以 CSS Variables 驱动关键视觉位
  - 特别为背景图预留变量（见 22.4“令牌 Hooks”）
- 主题宿主与导入
  - 主题管理器（加载/解析/持久化/导出）：[frontend_projects/SmartTavern/src/features/themes/manager.ts](frontend_projects/SmartTavern/src/features/themes/manager.ts)
  - 主题包解析与校验： [frontend_projects/SmartTavern/src/features/themes/pack.ts](frontend_projects/SmartTavern/src/features/themes/pack.ts)
  - 运行时加载顺序：在应用挂载前应用 tokens + CSS，挂载后按开关可选启用脚本
- 沙盒桥接与 API
  - 宿主侧桥接/白名单 API： [frontend_projects/SmartTavern/src/features/themes/sandbox/host.ts](frontend_projects/SmartTavern/src/features/themes/sandbox/host.ts)
  - 客户端侧最小运行时： [frontend_projects/SmartTavern/src/features/themes/sandbox/client.ts](frontend_projects/SmartTavern/src/features/themes/sandbox/client.ts)
  - 安全策略：iframe sandbox + CSP；禁止脚本直接 DOM/网络
- UI 与开关
  - Themes 页面：导入/启用/导出/重置/信任开关
  - App Settings 页面：全局“允许主题脚本”“权限级别”开关（默认关闭）

---

### 23.4 背景修改的两条路径（对比）

- 只想把纯色换成图片（静态背景）：
  - 直接用“无 JS 层”——在主题包 tokens 中设置 --st-surface-bg-image 等变量即可，零代码、零 API。
- 想做“动态背景”（按时间/滚动变化）或复杂动效：
  - 启用“可选 JS 层”——通过 ThemeHost 的 replaceBackground + addGlobalCSS 等 API 完成；默认关闭，需信任后启用。

---

结论：
- 开发阶段需要“预埋可定制点”。简单场景靠 CSS 变量 + 稳定选择器即可，无需 JS API；复杂动态美化再暴露受控的 ThemeHost API（沙盒执行）。这样既满足“导入单个主题文件即可覆盖”的便捷性，又兼顾可扩展与安全性。
## 24) 外观 Composables 使用指南（useAppearanceThreaded / useAppearanceSandbox）

本节说明如何在 UI 中复用已抽离的“外观设置”逻辑，避免重复实现 CSS 变量读写、本地持久化与主题扩展广播。

参考实现文件：
- [useAppearanceThreaded.js](../src/composables/appearance/useAppearanceThreaded.js:1)
- [useAppearanceSandbox.js](../src/composables/appearance/useAppearanceSandbox.js:1)
- 使用示例页签：
  - [ThreadedAppearance.vue](../src/components/sidebar/tabs/ThreadedAppearance.vue:1)
  - [SandboxAppearance.vue](../src/components/sidebar/tabs/SandboxAppearance.vue:1)

核心能力：
- 统一读写与校验各类 CSS 变量（px / 单位无关）
- 生成可持久化的 Snapshot（localStorage 键位独立）
- 定时保存变更并广播给主题扩展（ThemeManager.applyAppearanceSnapshot）
- 不执行任何外部脚本，安全仅限样式令牌层面

最小使用示例（楼层对话外观）：
```ts
<script setup>
import useAppearanceThreaded from '@/composables/appearance/useAppearanceThreaded'

const {
  state,
  initFromCSS,
  startAutoSave,
  setRootVar,
  setRootVarUnitless,
} = useAppearanceThreaded()

// 解构用于模板绑定（名称与 CSS 变量挂钩）
const {
  contentFontSize, nameFontSize, badgeFontSize, floorFontSize, avatarSize,
  chatWidth, inputHeight,
  contentLineHeight, messageGap, cardRadius, stripeWidth,
  threadedBgOpacityPct, threadedMsgBgOpacityPct, threadedListBgOpacityPct, threadedInputBgOpacityPct,
  thAspectX, thAspectY, thMaxWidthPct, thPadding, thRadius,
} = state

let stop = null
onMounted(() => {
  initFromCSS()
  stop = startAutoSave({ intervalMs: 1000 }) // 自动保存 + 广播
})
onBeforeUnmount(() => { stop?.() })

// 事件处理与 CSS 写入（示例）
function onMessageGapRangeInput(e) {
  messageGap.value = Number(e.target.value)
  setRootVar('--st-message-gap', messageGap.value)
}
</script>
```

前端沙盒外观示例类似，只需替换为：
```ts
import useAppearanceSandbox from '@/composables/appearance/useAppearanceSandbox'
const { state, initFromCSS, startAutoSave, setRootVar, setRootVarUnitless } = useAppearanceSandbox()
```

广播机制：
- 组合式在每次自动保存时调用 ThemeManager.applyAppearanceSnapshot(snapshot)
- 外部主题/扩展可通过 ThemeManager.registerExtension 注册监听器接收快照并自定义美化调整（详见下一节）

持久化键位（localStorage）：
- 楼层对话：st.appearance.threaded.v1
- 前端沙盒：st.appearance.sandbox.v1

可调令牌（节选，详见 tokens 与 contract）：
- 尺寸/密度：--st-content-font-size, --st-name-font-size, --st-message-gap, --st-card-radius, --st-stripe-width, ...
- 楼层内 HTML 舞台：--st-threaded-stage-aspect, --st-threaded-stage-maxw, --st-threaded-stage-padding, --st-threaded-stage-radius
- 沙盒舞台：--st-sandbox-aspect, --st-sandbox-max-width, --st-sandbox-padding, --st-sandbox-radius
- 不透明度（0~1）：--st-threaded-bg-opacity, --st-threaded-msg-bg-opacity, --st-threaded-list-bg-opacity, --st-threaded-input-bg-opacity, --st-sandbox-bg-opacity, --st-sandbox-stage-bg-opacity

参考：
- 令牌基线：[tokens.css](../src/styles/tokens.css:1)
- 稳定契约：[contract.json](../public/themes/contract.json:1)


## 25) 主题扩展接口（运行时扩展点）

本节说明如何在“不执行第三方脚本”的前提下，为主题作者或站内扩展提供“外观联动”的二次美化点。该扩展仅运行在应用自身上下文内，默认安全；若未来开放脚本，将在沙盒内通过 Host 桥接限制能力（详见 21 章“主题 2.0”）。

核心 API（来自 ThemeManager）：
- registerExtension(ext): () => void
- unregisterExtension(id: string): void
- getExtensions(): ThemeExtension[]
- applyAppearanceSnapshot(snapshot: ThemeAppearanceSnapshot): void

相关类型定义：
- [theme.d.ts](../src/types/theme.d.ts:1)
  - ThemeAppearanceSnapshot：外观面板广播的快照（字段会小步扩展）
  - ThemeExtension：扩展对象，包含 id/enabled/scopes/applyAppearance(snapshot)
  - ThemeManagerAPI：扩展注册与广播 API

运行时实现：
- [manager.js](../src/features/themes/manager.js:1)：内部维护 __extensions 注册表；广播时依次调用 ext.applyAppearance(snapshot)（仅 enabled !== false 的条目）
- [store.js](../src/features/themes/store.js:1)：主题令牌与附加 CSS 注入、状态持久化

最小扩展示例（站内扩展，响应外观快照动态微调 Token）：
```ts
<script setup>
import ThemeManager from '@/features/themes/manager'
import useThemeHost from '@/composables/useThemeHost' // 可选：提供 async 初始化与便捷封装

const { registerExtension } = useThemeHost() // 也可直接使用 ThemeManager.registerExtension
let dispose = null

onMounted(async () => {
  // 注册一个轻量扩展：当用户在“外观”页签调整圆角/间距时，顺带微调另一枚 Token
  dispose = await registerExtension({
    id: 'st.demo.token-follow',
    enabled: true,
    scopes: ['chat-threaded', 'settings-view'],
    applyAppearance(snapshot) {
      // 示例：当 cardRadius 变化时，派生一个动态投影强度（仅示意）
      const r = typeof snapshot.cardRadius === 'number' ? snapshot.cardRadius : 12
      const shadow = r >= 16 ? '0 16px 40px rgba(0,0,0,0.10)' : '0 8px 24px rgba(0,0,0,0.08)'
      // 通过 Store 安全设置 Token（会持久化到当前主题包）
      ThemeManager.store?.setToken?.('--st-shadow-md', shadow)
    },
  })
})

onBeforeUnmount(() => { dispose?.() })
</script>
```

注意事项：
- 扩展回调仅接收外观快照对象，不包含业务数据，不能访问消息/会话。
- 该扩展模型默认不执行任意外部脚本，仅允许应用内注册对象；未来若开放受信主题脚本，将强制进入沙盒并经权限/作用域白名单校验。
- Token 覆盖优先级：tokens.css 基线 < 主题包 tokens/css < 外观面板即时覆盖（组合式直接写 :root）; 扩展可使用 ThemeManager.store.setToken 做“主题级”持久化，也可直接写 CSS 变量仅做临时视觉调节（不推荐覆盖面板即时变量）。

调试与窗口暴露（可选）：
- [main.js](../src/main.js:1) 初始化期间可在 dev 模式选择暴露 window.STTheme 便于调试当前主题状态（manager 已支持 exposeToWindow 选项）

推荐集成步骤：
1) 在页面/插件中调用 useThemeHost() 或直接使用 ThemeManager.registerExtension 注册扩展对象
2) 在 applyAppearance(snapshot) 内根据快照字段（字号、间距、圆角、透明度、舞台比例等）决定要追加/覆盖的 tokens 或 CSS（尽量使用 setToken 保持一致性）
3) 在组件卸载时调用返回的 dispose() 注销扩展

至此，“外观面板 → 扩展”的联动链路闭环：
- 用户拖动滑条 → 组合式写 var + 周期 save + ThemeManager.applyAppearanceSnapshot → 扩展实时接收并做补充美化

## 26) 主题扩展接口文档与最佳实践（详细）

以下内容对第 25 节补充更完整的接口说明、示例与注意事项，帮助在“不执行外部脚本”的前提下编写站内美化扩展。

核心实现与类型：
- 扩展注册/广播：[manager.js](../src/features/themes/manager.js:1)
- 主题令牌/样式注入：[store.js](../src/features/themes/store.js:1)
- 扩展类型与快照结构：[theme.d.ts](../src/types/theme.d.ts:1)

可用 API（运行时）：
- ThemeManagerAPI.registerExtension(ext): () => void
- ThemeManagerAPI.unregisterExtension(id: string): void
- ThemeManagerAPI.getExtensions(): ThemeExtension[]
- ThemeManagerAPI.applyAppearanceSnapshot(snapshot: ThemeAppearanceSnapshot): void
- ThemeStoreAPI.setToken(name, value, {persist?}): void

快照字段（节选，详见类型定义）：
- Threaded/common：contentFontSize, nameFontSize, messageGap, cardRadius, stripeWidth, chatWidth, inputHeight...
- 透明度（百分比）：threadedBgOpacityPct, threadedMsgBgOpacityPct, threadedListBgOpacityPct, threadedInputBgOpacityPct, sandboxBgOpacityPct, sandboxStageBgOpacityPct
- 楼层内舞台：thAspectX, thAspectY, thMaxWidthPct, thPadding, thRadius
- 前端沙盒舞台：sandboxAspectX, sandboxAspectY, sandboxMaxWidth, sandboxPadding, sandboxRadius

最小扩展（只记录快照，无副作用）：
```ts
// 任意组件/插件内
import ThemeManager from '@/features/themes/manager'

const dispose = ThemeManager.registerExtension({
  id: 'st.ext.logger',
  enabled: true,
  scopes: ['settings-view'], // 逻辑范围，可留空
  applyAppearance(snapshot) {
    console.debug('[st.ext.logger] appearance snapshot:', snapshot)
  },
})
// 在组件卸载或停用扩展时：dispose()
```

动态 Token 跟随（将卡片圆角派生为阴影强度，仅作为示例）：
```ts
import ThemeManager from '@/features/themes/manager'

const dispose = ThemeManager.registerExtension({
  id: 'st.ext.shadow-follow',
  enabled: true,
  scopes: ['chat-threaded'],
  applyAppearance(snapshot) {
    const r = typeof snapshot.cardRadius === 'number' ? snapshot.cardRadius : 12
    const shadow = r >= 16 ? '0 16px 40px rgba(0,0,0,0.10)' : '0 8px 24px rgba(0,0,0,0.08)'
    // 使用 Store.setToken 进行主题级持久化（覆盖当前主题包 tokens）
    ThemeManager.store?.setToken?.('--st-shadow-md', shadow, { persist: true })
  },
})
```

通过组合式封装（推荐集成方式）：
```ts
// 组合式封装已提供初始化与便捷 API
import useThemeHost from '@/composables/useThemeHost'
const { registerExtension, unregisterExtension } = useThemeHost()
let dispose = null

onMounted(async () => {
  dispose = await registerExtension({
    id: 'st.ext.palette-tweak',
    enabled: true,
    applyAppearance(snap) {
      if ((snap.contentFontSize ?? 18) >= 20) {
        // 字体偏大时，微调强调色饱和度（示例）
        ThemeManager.store?.setToken?.('--st-accent', '74 222 128') // 绿色系
      }
    },
  })
})
onBeforeUnmount(() => { dispose?.() })
```

最佳实践与注意：
1) 默认不执行外部/不受信 JS。扩展仅运行在应用自身上下文内，属于“站内插件”，安全边界受我们掌控。
2) 优先改 Token，再改 CSS。ThemeStore.setToken 会持久化，附加 CSS 尽量少、精准（参考 [contract.json](../public/themes/contract.json:1) 的稳定选择器）。
3) 不读业务数据/不改业务逻辑。扩展仅联动样式层；不要尝试访问消息内容、鉴权信息等。
4) 冲突与优先级：tokens.css 基线 < 主题包 tokens/css < 外观面板即时覆盖（组合式写入 :root） < 扩展可能再次 setToken。若出现冲突，以“用户最近一次操作可见”为原则。
5) 卸载清理：registerExtension 返回的 dispose() 请在组件卸载或禁用扩展时调用，释放注册项。


## 27) 本地运行与构建验证（外观持久化 + 主题导入 + 扩展广播）

目标：在开发与静态产物（dist）环境验证外观面板与主题系统的端到端行为。

开发环境（Vite dev）：
1) 安装依赖
   - Windows: 在仓库根目录或项目目录执行 npm ci
2) 启动
   - Windows(cmd)：参照项目配置或直接执行 npm run dev
3) 验证外观面板
   - 打开 Appearance → “楼层对话/前端沙盒”页签
   - 调整滑条与数字框，确认页面样式实时变化、刷新后仍保持（localStorage）
   - 检查控制台是否有 ThemeManager.applyAppearanceSnapshot 的扩展日志（如注册了示例扩展）
4) 主题导入
   - 打开 Appearance → “主题”页签
   - 导入一个 JSON 主题（.sttheme.json），确认 tokens/CSS 生效，刷新后仍保持（localStorage）
   - “重置主题”后应恢复默认 tokens/CSS

构建产物（静态服务器）：
1) 构建
   - npm run build
2) 静态服务（任选其一）
   - npx serve dist
   - 或任何静态服务器（Nginx/Netlify/Cloudflare Pages）
3) 重复上述“外观面板/主题导入”验证步骤，确保在纯静态环境下依旧可用
4) 兼容性检查
   - 在不同浏览器（Chromium/Firefox/Safari）尝试主题导入与外观持久化
   - 检查 contract.json 与 tokens.css 是否随产物一并可访问

常见问题：
- 问：外观变更刷新不保留？
  - 查 localStorage: st.appearance.threaded.v1 / st.appearance.sandbox.v1 是否写入。若被浏览器阻止“第三方存储”，请检查站点设置。
- 问：主题导入后无效？
  - 检查导入文件结构是否符合 [pack.js](../src/features/themes/pack.js:1) 的 normalize/validate 规则（tokens 键必须以 -- 开头）。
- 问：扩展未收到快照？
  - 确认已通过 ThemeManager.registerExtension 正常注册，且外观组合式在自动保存周期内调用了 ThemeManager.applyAppearanceSnapshot（已内置于组合式）。
